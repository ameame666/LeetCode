# 题目: 构造一个长度为n，每个数都不超过m的全为正数的数组，使数组中没有相邻元素的按位与等于0，求有多少个数组满足要求
# 相邻元素按位与j & k
""""
这个问题可以通过动态规划来解决。我们可以定义一个二维数组dp，其中dp[i][j]表示长度为i的数组，最后一个元素为j时满足条件的数组数量。然后我们可以根据状态转移来计算dp[i][j]。

首先，我们需要处理边界情况，即当i=1时，dp[i][j]应该初始化为1，因为长度为1的数组只有一个元素，没有相邻元素，所以一定满足条件。

然后，对于i>1的情况，我们可以考虑从dp[i-1]中转移过来。假设dp[i-1]中的某个元素dp[i-1][k]表示长度为i-1的数组，最后一个元素为k时满足条件的数组数量。现在我们想构造长度为i的数组，最后一个元素为j，要保证没有相邻元素的按位与等于0，那么我们需要确保k与j的按位与不等于0，即(k & j) != 0。

为了计算dp[i][j]，我们可以遍历k，对于每个k，如果(k & j) != 0，说明可以构造长度为i的数组，最后一个元素为j，并且满足条件，所以我们可以将dp[i-1][k]累加到dp[i][j]中。

最后，遍历dp[n]数组中的所有元素，将它们相加，即可得到满足条件的数组数量。
"""
def countArrays(n, m):
    MOD = 10**9 + 7
    dp = [[0] * (m+1) for _ in range(n+1)]
    
    # 初始化边界情况
    for j in range(1, m+1):
        dp[1][j] = 1
    
    # 动态规划
    for i in range(2, n+1):
        for j in range(1, m+1):
            for k in range(1, m+1):
                if (j & k) != 0:
                    dp[i][j] = (dp[i][j] + dp[i-1][k]) % MOD
    
    # 计算总数量
    total = sum(dp[n]) % MOD
    return total
